import jax
import jax.numpy as jnp
import matplotlib.pyplot as plt
import random
from jax import jit, lax, tree_util
from functools import partial


@jit
def project_element(value):
    return lax.cond(value == 0.5, 
                    lambda _: jnp.array([1, 0]), 
                    lambda _: jnp.array([0, 1]), 
                    operand=None)
    
@jit
def _vdot(spin1, spin2):
    dot_product = jnp.sum(spin1 * spin2, axis=-1)
    result = jnp.prod(dot_product)
    
    return result


class Model:
    """
    A model that represents a 2D lattice of spins with a Hamiltonian
    """

    def __init__(self, L1, L2, key = jax.random.PRNGKey(0)) -> None:
        self.L1 = L1
        self.L2 = L2
        #self.key = jax.random.PRNGKey(seed)
        self.key = key

    def _tree_flatten(self):
        children = (self.key,)
        aux_data = {"L1": self.L1, "L2": self.L2}
        return (children, aux_data)
    
    @classmethod
    def _tree_unflatten(cls, aux_data, children):
        return cls(aux_data['L1'], aux_data['L2'], *children)

    @jit
    def project_spin(self, spin):
        """
        Helper function. Given the spins (L1, L2, 2), project them down to a shape (L1*L2)

        In lieu of the one-hot spin representation, each spin entry [1,0] and [0,1] is mapped to 1/2 and -1/2 respectively
        """
        return jnp.array(spin[:,:,0].flatten(), dtype=jnp.float32) - 0.5#_project_spin(spin)

    @jit
    def unproject_spin(self, spin):
        """
        Helper function. Given the spins (L1*L2), project them back to a shape (L1, L2, 2)
        """
        assert spin.shape == (self.L1 * self.L2,), f"Invalid shape {spin.shape} for unproject_spin"
        return jnp.array([[project_element(spin[i * self.L2 + j]) for j in range(self.L2)] for i in range(self.L1)])

    #@jit
    def _get_random_spins(self, subkey):
        return jax.random.choice(subkey, jnp.array([[1, 0], [0, 1]]), shape=(self.L1,self.L2))

    def get_random_spins(self):
        """
        return: a 2D array (L1, L2, 2) of random spins
        Each site has either spin up [1,0] or spin down [0,1]
        """
        #raise NotImplementedError("get_random_spins is not implemented properly")
        self.key, subkey = jax.random.split(self.key)
        return self._get_random_spins(subkey)
    
    #@jit
    def flip_spin_at(self, spin, i, j):
        """
        Flip the spin at position (i, j) in the input spin array
        """
        def flip_if_one(spin, i, j):
            spin = spin.at[i, j].set(jnp.array([1, 0]))
            return spin

        def flip_if_zero(spin, i, j):
            spin = spin.at[i, j].set(jnp.array([0, 1]))
            return spin
        
        condition = jnp.array_equal(spin[i, j], jnp.array([0, 1]))
        spin = jax.lax.cond(condition, flip_if_one, flip_if_zero, spin, i, j)
        
        return spin
    
    @jit
    def _flip_random_spin(self, spin, subkey):
        subkey1, subkey2 = jax.random.split(subkey, 2)
        L1 = spin.shape[0]
        L2 = spin.shape[1]
        i = jax.random.randint(subkey1, (1,), 0, L1)[0]
        j = jax.random.randint(subkey2, (1,), 0, L2)[0]
        # Use JAX's conditional operations instead of assertions
        return self.flip_spin_at(spin, i, j)

    def flip_random_spin(self, spin):
        """
        return: a 2D array (L1, L2, 2) of spins with one random spin flipped
        """
        self.key, subkey = jax.random.split(self.key, 2)
        return self._flip_random_spin(spin, subkey)
    
    @partial(jit, static_argnums = (2,))
    def generate_local_spins(self, spin, change=1):
        """
        Generate a set of spins with local perturbation around the input spin (flip one spins)

        Change: consider how much spins can be changed at maximum (currently only allows change = 1 or 2)
        """
        assert change == 1 or change == 2, f"Invalid change value {change}"
        result = [spin]
        result.extend([self.flip_spin_at(spin, i, j) for i in range(self.L1) for j in range(self.L2)])
        
        if change == 2:
            result.extend([self.flip_spin_at(self.flip_spin_at(spin, i, j), k, l)
                            for i in range(self.L1) for j in range(self.L2)
                            for k in range(self.L1) for l in range(self.L2)
                            if (k * self.L2 + l) > (i * self.L2 + j)])

        return result

    @jit
    def vdot(self, spin1, spin2):
        """
        #get the overlap expectation value <spin1|spin2>
        #where spin1 and spin2 are 2D arrays (L1, L2) generated by get_random_spins or equivalent
        """
        #assert spin1.dtype == int, f"Hdot cannot handle spins of type {spin1.dtype}. Please convert this to int"
        #assert jnp.all(jnp.sum(spin1, axis = -1) == 1), "spin1 is not properly normalized"
        #assert jnp.all(jnp.sum(spin2, axis = -1) == 1), "spin2 is not properly normalized"
        dot_product = jnp.sum(spin1 * spin2, axis=-1)
        result = jnp.prod(dot_product)
        return result

tree_util.register_pytree_node(Model,
                               Model._tree_flatten,
                               Model._tree_unflatten)

if __name__ == "__main__":
    model = Model(2, 3, key = jax.random.PRNGKey(0))
    spins = model.get_random_spins()
    projected_spins = model.project_spin(spins)
    model.unproject_spin(projected_spins)