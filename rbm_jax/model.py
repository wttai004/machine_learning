import jax
import jax.numpy as jnp
import matplotlib.pyplot as plt
import random

class Model:
    """
    A model that represents a 2D lattice of spins with a Hamiltonian
    """

    def __init__(self, L1, L2, seed = 0) -> None:
        self.L1 = L1
        self.L2 = L2
        self.Hamiltonian = jnp.zeros((L1, L2, L1, L2, 2, 2, 2, 2), dtype=int)
        self.key = jax.random.PRNGKey(seed)

    def project_spin(self, spin):
        """
        Helper function. Given the spins (L1, L2, 2), project them down to a shape (L1*L2)

        In lieu of the one-hot spin representation, each spin entry [1,0] and [0,1] is mapped to 1/2 and -1/2 respectively
        """
        return jnp.array(spin[:,:,0].flatten(), dtype=jnp.float32) - 0.5

    def unproject_spin(self, spin):
        """
        Helper function. Given the spins (L1*L2), project them back to a shape (L1, L2, 2)
        """
        assert spin.shape == (self.L1 * self.L2,), f"Invalid shape {spin.shape} for unproject_spin"
        return jnp.array([[[1, 0] if spin[i * self.L2 + j] == 0.5 else [0, 1] for j in range(self.L2)] for i in range(self.L1)])


    def get_random_spins(self):
        """
        return: a 2D array (L1, L2, 2) of random spins
        Each site has either spin up [1,0] or spin down [0,1]
        """
        #raise NotImplementedError("get_random_spins is not implemented properly")
        self.key, subkey = jax.random.split(self.key)
        spins_flat = jax.random.choice(subkey, jnp.array([[1, 0], [0, 1]]), shape=(self.L1 * self.L2,))
        spins = spins_flat.reshape(self.L1, self.L2, 2)
        return spins
    
    def flip_random_spin(self, spin1):
        """
        return: a 2D array (L1, L2, 2) of spins with one random spin flipped
        """
        spin2 = spin1.copy()
        self.key, subkey = jax.random.split(self.key)
        i = jax.random.randint(subkey, (1,), 0, self.L1)[0]
        self.key, subkey = jax.random.split(self.key)
        j = jax.random.randint(subkey, (1,), 0, self.L2)[0]
        i, j = random.randint(0, self.L1-1), random.randint(0, self.L2-1)
        assert spin1[i,j,0] == 0 or spin1[i,j,0] == 1, f"Invalid spin value {spin1[i,j,0]}"
        assert spin2[i,j,0] == 0 or spin2[i,j,0] == 1, f"Invalid spin value {spin2[i,j,0]}"
        spin2 = spin2.at[i, j].set([1, 0] if spin1[i, j, 0] == 0 else [0, 1])
        return spin2
    
    def flip_spin_at(self, spin, i, j):
        """
        Flip the spin at position (i, j) in the input spin array
        """
        new_spin = spin.at[i, j].set(jnp.array([1, 0]) if spin[i, j, 0] == 0 else jnp.array([0, 1]))
        return new_spin
    
    def generate_local_spins(self, spin, change=1):
        """
        Generate a set of spins with local perturbation around the input spin (flip one spins)

        Change: consider how much spins can be changed at maximum (currently only allows change = 1 or 2)
        """
        assert change == 1 or change == 2, f"Invalid change value {change}"
        result = [spin]
        result.extend([self.flip_spin_at(spin, i, j) for i in range(self.L1) for j in range(self.L2)])
        
        if change == 2:
            result.extend([self.flip_spin_at(self.flip_spin_at(spin, i, j), k, l)
                           for i in range(self.L1) for j in range(self.L2)
                           for k in range(self.L1) for l in range(self.L2)
                           if (k * self.L2 + l) > (i * self.L2 + j)])

        return result



    def vdot(self, spin1, spin2):
        """
        #get the overlap expectation value <spin1|spin2>
        #where spin1 and spin2 are 2D arrays (L1, L2) generated by get_random_spins or equivalent
        """
        #assert spin1.dtype == int, f"Hdot cannot handle spins of type {spin1.dtype}. Please convert this to int"
        #assert np.all(np.sum(spin1, axis = -1) == 1), "spin1 is not properly normalized"
        #assert np.all(np.sum(spin2, axis = -1) == 1), "spin2 is not properly normalized"
        # Element-wise multiplication and summation
        dot_product = jnp.sum(spin1 * spin2, axis=-1)
        result = jnp.prod(dot_product)
        
        return result


if __name__ == "__main__":
    print("Hello world")